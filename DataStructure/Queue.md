# 큐 Queue
> 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
> 
> 
> 
><자료구조>
> - **FIFO(First-In-First-Out) 선입선출**
> - **저장된 원소 중 첫 번째 원소(또는 삭제된 위치)** = **머리(Front)**
> - **저장된 원소 중 마지막 원소** = **꼬리(Rear)**
>
><연산>
> - **enQueue(item)** - 큐의 뒤쪽 (rear 다음)에 원소를 삽입
> - **deQueue** - 큐의 앞쪽 (front) 에서 원소를 삭제하고 반환
> - **createQueue** - 공백 상태의 큐를 생성
> - **isEmpty** 큐가 공백상태인지 확인
> - **isFull** 큐가 포화상태인지 확인
> - **Qpeek** 큐의 앞쪽(front)에서 원소를 삭제 없이 반환 

## 큐의 구현
### 선형큐
- 1차원 배열 이용한 큐
  - 큐의 크기 = 배열의 크기
  - 초기상태 : front = rear = -1
  - 공백상태 : front == rear # front와 rear가 같으면 비어있는거구나
  - 포화상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)


참고) 자료구조 파이썬 파일 생성 시 queue라는 이름 사용하면 모듈이름 겹쳐서 오류발생가능

### 원형큐
- 선형 큐의 문제점 : 선형 큐를 이용하여 원소의 삽입, 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고 rear = n-1인 상태, 즉 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨
- 해결방법 1 : "앞으로 밀착~!" 매 연산이 이뤄질 떄마다 저장된 원소들을 배열의 앞부분을 모두 이동시킴. 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐.
- 해결방법 2 : 1차원 배열을 사용하되, 논리적으로는 **배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정**하고 사용.
  - 초기상태 : front = rear = 0
  - index의 순환 : n-1 이후 0으로 이동해야 함. 이를 위해 나머지 연산자 mod를 사용함
  - front 변수 : 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠.
  - 공백상태 : front == rear
  - 포화상태 : 삽입할 rear의 다음 위치 == 현재 front

| |삽입 위치|삭제 위치|
|------|---|---|
|선형큐|테스트2|테스트3|
|원형큐|테스트2|테스트3|





### 연결 큐
#### 단순 연결 리스트를 이용한 큐

### deque(덱)

### 우선순위 큐
운영체제 cs







