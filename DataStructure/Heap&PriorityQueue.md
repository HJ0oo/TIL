# 힙(Heap) 자료구조

> 힙(Heap)은 **완전 이진 트리**의 일종으로, 특정한 속성을 만족하는 자료구조입니다.<br>
> 주로 우선순위 큐와 같은 데이터 구조를 구현할 때 사용됩니다. 힙은 크게 두 가지 유형이 있습니다: 최대 힙(Max Heap)과 최소 힙(Min Heap).<br>
> keyword : 부모 > 자식 / 부모 < 자식

## 1. 기본 개념

### 1.1. 힙의 정의

- **완전 이진 트리(Complete Binary Tree)**: 모든 레벨이 완전히 채워져 있으며, 마지막 레벨만 노드가 왼쪽부터 채워져 있는 이진 트리입니다.
- **힙 속성(Heap Property)**:
  - **최대 힙(Max Heap)**: 모든 부모 노드는 자식 노드보다 크거나 같아야 합니다.
  - **최소 힙(Min Heap)**: 모든 부모 노드는 자식 노드보다 작거나 같아야 합니다.

### 1.2. 힙의 구성

힙은 배열로 구현할 수 있으며, 배열의 인덱스와 트리의 노드 간에는 다음과 같은 관계가 있습니다:

- **부모 노드의 인덱스**: `i`
- **왼쪽 자식 노드의 인덱스**: `2*i + 1`
- **오른쪽 자식 노드의 인덱스**: `2*i + 2`
- **부모 노드의 인덱스**: `(i - 1) // 2`

## 2. 주요 연산
 
### 2.1. 삽입(Insert)

- 새 요소를 배열의 끝에 추가합니다.
- 부모 노드와 비교하여 힙 속성을 유지할 때까지 상향식으로 이동(퍼클리퍼)합니다.

### 2.2. 삭제(Delete)

- (1) **루트** 노드를 제거하고, (2) 배열의 **마지막 요소**를 루트 노드로 이동합니다.
- (3) 자식 노드와 비교하여(max힙이라면 2개의 자식 노드 중 큰 거랑 바꿔야지! - 한쪽 서브트리는 그 이후로 더 이상 볼 필요가 없으니까) 힙 속성을 유지할 때까지 하향식으로 이동(힙화)합니다.

### 2.3. 힙화(Heapify)

- **상향식 힙화(Bottom-Up Heapify)**: 노드를 삽입할 때 사용합니다. 새 노드를 올려 보내며 힙 속성을 유지합니다.
- **하향식 힙화(Top-Down Heapify)**: 삭제할 때 사용합니다. 노드를 내리며 힙 속성을 유지합니다.

### 2.4. 힙 최대값/최소값 조회

- **최대 힙(Max Heap)**: 루트 노드에 위치합니다.
- **최소 힙(Min Heap)**: 루트 노드에 위치합니다.

## 3. 힙과 이진 트리의 관계

- **이진 트리(Binary Tree)**: 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다.
- **완전 이진 트리**: 모든 레벨이 완전히 채워진 이진 트리로, 힙은 완전 이진 트리의 형태를 가집니다.
- **이진 힙(Binary Heap)**: 완전 이진 트리의 형태를 가지면서 힙 속성을 만족하는 트리입니다.

## 4. 힙의 활용

- **우선순위 큐(Priority Queue)**: 우선순위에 따라 데이터를 빠르게 추가 및 제거할 수 있습니다.
  - 힙의 키를 우선순위로 활용하여 우선순위 큐를 구현할 수 있다. 키값이 가장 큰 노드나 가장 작은 노드를 찾기에 적합한 자료구조니까..!
- **정렬(Heap Sort)**: 힙을 사용하여 데이터를 정렬할 수 있습니다.
- **그래프 알고리즘**: 다익스트라 알고리즘 등에서 최단 경로를 찾는 데 사용됩니다.

## 5. 시간 복잡도

- **삽입**: O(log n)
  - 전체적인 시간 n개의 데이터는 n * log n 이겠지
- **삭제**: O(log n)
- **최대/최소값 조회**: O(1)

## 6. 예제 코드 (Python)

```python
import heapq

# 최소 힙의 사용 예
min_heap = []
heapq.heappush(min_heap, 5)
heapq.heappush(min_heap, 2)
heapq.heappush(min_heap, 7)

print("최소값:", heapq.heappop(min_heap))  # 2
print("다음 최소값:", heapq.heappop(min_heap))  # 5

# 최대 힙의 사용 예
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -2)
heapq.heappush(max_heap, -7)

print("최대값:", -heapq.heappop(max_heap))  # 7
print("다음 최대값:", -heapq.heappop(max_heap))  # 5
```

힙 자료구조는 다양한 알고리즘과 문제 해결에 유용하며, 배열을 기반으로 효율적으로 구현할 수 있는 데이터 구조입니다.


# 우선순위 큐(Priority Queue)

우선순위 큐(Priority Queue)는 데이터 요소가 우선순위(priority)와 함께 저장되고, 요소가 큐에서 추출될 때 우선순위에 따라 처리되는 큐입니다. 기본적인 큐와는 달리, 우선순위 큐에서는 요소가 삽입될 때의 순서와는 상관없이 우선순위에 따라 요소를 추출합니다.

## 1. 기본 개념

### 1.1. 정의

- **우선순위 큐(Priority Queue)**: 큐의 각 요소가 우선순위를 가지며, 우선순위가 높은 요소가 먼저 제거되는 큐입니다. 우선순위는 숫자, 문자, 기타 기준으로 설정될 수 있습니다.

### 1.2. 동작 방식

- **삽입**: 새로운 요소를 큐에 추가하고, 그 요소의 우선순위에 따라 위치를 조정합니다.
- **삭제**: 우선순위가 가장 높은 요소(또는 가장 낮은 요소)가 큐에서 제거됩니다.
- **최상위 조회**: 현재 큐에서 가장 높은 우선순위를 가진 요소를 조회합니다.

## 2. 구현 방법

우선순위 큐는 다양한 방식으로 구현할 수 있으며, 각 방법에는 장단점이 있습니다.

### 2.1. 배열(Array)

- **삽입**: 배열의 끝에 추가하고, 우선순위에 따라 배열을 정렬합니다. (O(n) 시간 복잡도)
- **삭제**: 배열의 첫 번째 요소를 제거하고, 나머지를 왼쪽으로 이동합니다. (O(n) 시간 복잡도)
- **최상위 조회**: 배열의 첫 번째 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.2. 연결 리스트(Linked List)

- **삽입**: 우선순위에 맞게 위치를 찾고 삽입합니다. (O(n) 시간 복잡도)
- **삭제**: 우선순위가 가장 높은 요소를 찾고 제거합니다. (O(1) 시간 복잡도)
- **최상위 조회**: 리스트의 첫 번째 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.3. 힙(Heap)

- **삽입**: 힙의 특성에 맞게 요소를 삽입하고, 힙 속성을 유지합니다. (O(log n) 시간 복잡도)
- **삭제**: 힙의 루트 요소를 제거하고, 힙 속성을 유지합니다. (O(log n) 시간 복잡도)
- **최상위 조회**: 힙의 루트 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.4. 이진 검색 트리(Binary Search Tree, BST)

- **삽입**: 우선순위에 따라 이진 검색 트리에 요소를 추가합니다. (O(log n) 평균 시간 복잡도)
- **삭제**: 우선순위가 가장 높은 요소를 찾아 삭제합니다. (O(log n) 평균 시간 복잡도)
- **최상위 조회**: 트리의 최대값을 조회합니다. (O(log n) 평균 시간 복잡도)

## 3. 힙을 사용한 우선순위 큐

힙을 사용한 우선순위 큐는 효율적인 삽입과 삭제 연산을 제공합니다. 이진 힙을 사용하면 다음과 같은 시간 복잡도를 가집니다:

- **삽입**: O(log n)
- **삭제**: O(log n)
- **최상위 조회**: O(1)

### 3.1. 힙의 동작

- **최대 힙(Max Heap)**: 가장 높은 우선순위를 가진 요소가 루트에 위치합니다. 삽입 시 새로운 요소를 트리의 마지막에 추가하고, 부모와 비교하여 힙 속성을 유지합니다. 삭제 시 루트 요소를 제거하고, 마지막 요소를 루트로 이동한 후, 하향식 힙화를 통해 힙 속성을 유지합니다.
- **최소 힙(Min Heap)**: 가장 낮은 우선순위를 가진 요소가 루트에 위치합니다. 삽입과 삭제 시의 동작은 최대 힙과 유사하지만, 비교 기준이 다릅니다.

## 4. 활용 사례

- **스케줄링**: 작업 스케줄링 및 작업 우선순위 결정.
- **그래프 알고리즘**: 다익스트라 알고리즘, 프림의 최소 신장 트리 알고리즘 등에서 최단 경로 계산.
- **알고리즘 설계**: 힙 정렬, A* 알고리즘 등.

## 5. 예제 코드 (Python)

```python
import heapq

# 우선순위 큐의 예제 (최소 힙 사용)
priority_queue = []
heapq.heappush(priority_queue, (3, 'Task A'))
heapq.heappush(priority_queue, (1, 'Task B'))
heapq.heappush(priority_queue, (2, 'Task C'))

print("최우선 작업:", heapq.heappop(priority_queue))  # (1, 'Task B')
print("다음 우선 작업:", heapq.heappop(priority_queue))  # (2, 'Task C')

# 우선순위 큐의 예제 (최대 힙 사용, 부호 변환 활용)
max_heap = []
heapq.heappush(max_heap, (-3, 'Task A'))
heapq.heappush(max_heap, (-1, 'Task B'))
heapq.heappush(max_heap, (-2, 'Task C'))

print("최대 우선 작업:", -heapq.heappop(max_heap)[0])  # 3
print("다음 최대 우선 작업:", -heapq.heappop(max_heap)[0])  # 2
```

우선순위 큐는 다양한 알고리즘과 응용에서 중요한 역할을 하며, 적절한 구현 방법을 선택하여 사용할 수 있습니다.