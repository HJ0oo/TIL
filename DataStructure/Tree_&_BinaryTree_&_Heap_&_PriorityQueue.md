# 트리 구조 (Tree Structure)
> ## 1. 트리란?
>
> 트리(Tree)는 **계층적**(hierarchical)인 데이터 구조로,
> **비선형** 자료구조이며, 원소들 간 1:n 관계를 가짐.<br>
> 하나의 루트 노드(Root Node)에서 시작해 여러 하위 노드들로 분기<br>
> 노드(**Node**)들과 이들을 연결하는 간선(Edge,**Vertex**)들로 이루어져 있음.<br>
> 노드 하나도 트리가 될 수 있다? - O
> 
> ## 2. 트리의 용어
> 
> - **노드(Node):** 트리의 기본 요소로, 데이터를 저장하는 단위
> - **루트 노드(Root Node):** 트리의 최상단에 위치한 노드로, 트리는 
>  루트 노드에서부터 시작. 터미널 노드, 단말 노드.
> - **리프 노드(Leaf Node):** 자식 노드가 없는 노드로, 트리의 가장 
> 단에 위치
> - **부모 노드(Parent Node):** 한 노드가 가지는 바로 위 단계의 
> 드
> - **자식 노드(Child Node):** 부모 노드로부터 분기된 하위 노드
> - **형제 노드(Sibling Node):** 같은 부모를 공유하는 노드들
> - **조상 노드:** 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
> - **자손 노드:** 서브 트리에 있는 하위 레벨 노드들
> - **서브트리(Subtree):** 하나의 노드와 그 노드의 모든 자식 노드들로 구성된 트리
>
> - **차수(Degree):**
>   - 노드의 차수 : 그 노드에 연결된 자식 노드의 수 @@@@@@@@@@@
>     - 리프 노드 : 차수가 0인 노드, 자식 노드가 없는 노드 
>   - 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값
> 
> - **높이(Height):**
>   - 노드의 높이 : 루트에서 해당 노드에 이르는 간선의 수. = 노드의 레벨. (루트 노드는 **레벨 0, 높이 0**)
>   - 트리의 높이 : 트레에 있는 노드의 높이 중 최댓값. 최대 레벨.
>
> +++ 공통조상 - 각 노드에서 가까운 공통조상 누군지 찾는 문제 풀어보기
> 
> ## 3. 트리의 특징 
> - **계층적 구조:** 트리는 계층적으로 데이터를 표현할 때 사용됩니다.
> - **사이클 없는 그래프:** 트리에는 사이클이 존재하지 않으며, 이는 트리의 방향성을 보장합니다. (형제노드끼리 연결할 수 없음)
> - **유일한 경로:** 두 노드 간의 경로는 항상 유일합니다.
> ## 4. 트리의 순회(Traversal)
> - **VLR 전위 순회(Preorder Traversal):** 루트 노드를 먼저 방문한 후 왼쪽 자식, 오른쪽 자식 순으로 방문합니다.
> - **LVR 중위 순회(Inorder Traversal):** 왼쪽 자식을 먼저 방문하고, 그 다음 루트 노드, 마지막으로 오른쪽 자식을 방문합니다.
> - **LRV 후위 순회(Postorder Traversal):** 왼쪽 자식과 오른쪽 자식을 먼저 방문한 후 루트 노드를 방문합니다.
> ```py
> def 전위순회(T) : # 현재 노드
>   if T :
>     visit(T)
>     순회(T.left)
>     순회(T.right)   # 중위순회와 후위순회는 순서만 바꾸면 됨.
> ```
> - **레벨 순회(Level Order Traversal):** 루트 노드부터 시작해 같은 레벨의 노드들을 왼쪽에서 오른쪽으로 순차적으로 방문합니다.



## 4. 이진 트리 (Binary Tree)
### 4-1. 정의 및 종류
- **정의:** 각 노드가 최대 두 개의 자식 노드 - 왼쪽 자식(Left Child)과 오른쪽 자식(Right Child)노드를 가지는 트리. 루트가 1번...
- tip) 코테 때 쓰는 건 일반적인 이진트리니까 구현해보기. 루트 1번인거 편견. 현실에서 이진트리는 그렇지 않음. 0번노드가 등장하기도 함. 일반적인 이진트리는 아무규칙도 없음. 100번... 다 가능 선입견 없이 할것
- 레벨 i 에서 노드의 최대 개수 2^i 개
- 높이가 h인 이진 트리가 가질 수 있는 노드 - 최대 개수 : 1+2+4...+2^h= 2^(h+1)-1 , 최소 개수 - h+1
- **종류:**
  - 포화(Full) 이진 트리 : 모든 레벨에 노드가 포화상태로 차 있는 이진트리(2^(h+1)-1개의 노드)
  - 완전(complete) 이진 트리 : 
    - 노드 수가 n개일 때 빈자리 없는 이진 트리 (높이 h일 때 2^h-1 <= n <= 2^(h+1)-1 겠지)
    - 왼쪽, 오른쪽 순서대로 빈자리 없이 잘 차 있는.
  - 편향 이진 트리 : 한쪽 방향의 자식 노드만을 가진 이진트리
    - 트리형태로 저장시 레벨이 기하급수적으로 줄어드는데, 편향이진트리가 되는건 사실상 이 트리라는 자료구조의 장점을 살리지 못한 것.
+++ 레드블랙트리 찾아보기

### 4-2. 이진 트리의 구현
주로 **링크드 노드(Linked Nodes)** 또는 **배열(Array)** 방식으로 구현
- **연결 리스트 방식:** 각 노드가 포인터를 통해 자식 노드들을 가리키는 방식입니다.
- **배열 방식:**
- 노드들을 배열에 저장하고, 자식 노드의 인덱스를 통해 트리를 구성. 완전 이진 트리의 경우 배열을 사용한 구현이 매우 효율적임.
- 단점 : 편향 이진 트리의 경우 메모리 공간 낭비 심함, 트리의 중간에 새로운 노드 삽입, 기존 노드 삭제할 경우 배열의 크기 변경이 어려움
  - 루트 노드 인덱스 1 부터 시작해서...
  - 노드 번호가 i일 때 - 부모노드 i//2 왼쪽 자식노드 2\*i 오른쪽 자식노드 2*i + 1 
  - 레벨 n의 노드 번호 시작 번호 : 2^n
```py
# 간선의 개수 N = 4
# 부모 자식 순
# 1 2 1 3 3 4 3 5
'''
1
| \
2  3
  / \
 4   5
'''
# 부모 번호를 인덱스로 자식노드 리스트 2개에 자식 번호 저장
if c1[p] == 0 :
  c1[p] = c
else :
  c2[p] = c
'''
      p   0 1 2 3 4 5
자식1 c1  - 2 0 4 0 0
자식2 c2  - 3 0 5 0 0
'''
# 자식 번호를 인덱스로 부모 번호를 저장
par[c] = p
'''
c   0 1 2 3 4 5
par 0 0 1 1 3 3
'''
# 루트 찾기, 조상 찾기
# 5번 노드의 조상찾기
c = 5
while par[c] != 0 :
  c = par[c]
  anc.append(c) # 조상 목록
root = c # 5번 타고 마지막까지 올라가면 root니까.
```
cf) 참고 - 수식트리(수식이진트리) :<br>
피연산자는 모두 리프 노드, 연산자는 루트 노드나 가지 노드






## 5. 이진 탐색 트리 (Binary Search Tree, BST)
- 이진 트리의 일종으로, 왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 큰 값들을 가집니다.
- **특징:** 이진 탐색 트리는 효율적인 검색, 삽입, 삭제를 지원합니다.
```py
arr = []
if target in arr : # in 연산자가 생각보다 시간복잡도가 큼 O(n)
```
이러한 구조 덕분에 데이터를 효율적으로 검색, 삽입, 삭제할 수 있음
평균적으로 시간 복잡도는 O(log n)입니다.<br>
BST의 성능은 트리의 균형 상태에 따라 달라지며, 최악의 경우(한쪽으로 치우친 트리)에는 O(n)의 성능을 보일 수 있습니다.<br>
tip) b형 난이도 가야 직접 구현 정도. 코테 시간동안 구현해서 쓰기는 어려우니까.

| **작업**          | **정렬되지 않은 리스트** | **정렬된 리스트** | **이진 탐색 트리(BST)** |
|-------------------|-------------------------|------------------|--------------------------|
| **탐색 (Search)**  | O(n)                    | O(log n)         | O(log n) (평균), O(n) (최악) |
| **삽입 (Insertion)**| O(1)                    | O(n)             | O(log n) (평균), O(n) (최악) |
| **삭제 (Deletion)** | O(n)                    | O(n)             | O(log n) (평균), O(n) (최악) |

삽입을 위해 root 부터 바닥노드까지 탐색하며 자기 위치 찾음
트리 높이 h 만큼 탐색시간 걸림 O(logN) = h



## 6. 힙(Heap)
### 6-1 힙 정의 및 유형
- 힙(Heap)은 **완전 이진 트리**의 일종임. @@@중요@@@
- 힙은 크게 두 가지 유형 : 최대 힙(Max Heap)과 최소 힙(Min Heap).
- **힙 속성(Heap Property)**:
  - **최대 힙(Max Heap)**: 모든 부모 노드는 자식 노드보다 크거나 같다.(루트 노드가 제일 큼)
  - **최소 힙(Min Heap)**: 모든 부모 노드는 자식 노드보다 작거나 같다.(루트 노드가 제일 작음)
> keyword : **부모** 랑 **자식** 값이랑 비교

### 6-2 힙 구현(배열)
- **부모 노드의 인덱스**: `i`
- **왼쪽 자식 노드의 인덱스**: `2*i + 1`
- **오른쪽 자식 노드의 인덱스**: `2*i + 2`
- **부모 노드의 인덱스**: `(i - 1) // 2`

### 6-3. 주요 연산 
#### 1. 삽입(Insert)
- 새 요소를 **배열의 끝에 추가**합니다.
- 부모 노드와 비교하여 힙 속성을 유지할 때까지 상향식으로 이동(퍼클리퍼)합니다.

#### 2. 삭제(Delete)
- (1) **루트** 노드를 제거하고, @@중요@@
- (2) 배열의 **마지막 요소**를 루트 노드로 일단 이동시킴.
- (3) 자식 노드와 비교하여(max힙이라면 2개의 자식 노드 중 큰 거랑 바꿔야지! - 한쪽 서브트리는 그 이후로 더 이상 볼 필요가 없으니까) 힙 속성을 유지할 때까지 하향식으로 이동(힙화)합니다.

#### 3. 힙화(Heapify)
- **상향식 힙화(Bottom-Up Heapify)**: 노드를 삽입할 때 사용합니다. 새 노드를 올려 보내며 힙 속성을 유지합니다.
- **하향식 힙화(Top-Down Heapify)**: 삭제할 때 사용합니다. 노드를 내리며 힙 속성을 유지합니다.


## 4. 힙의 활용
- **우선순위 큐(Priority Queue)**: 우선순위에 따라 데이터를 빠르게 추가 및 제거할 수 있습니다.
  - **힙의 키를 우선순위로 활용**하여 우선순위 큐를 구현할 수 있다. 키값이 가장 큰 노드나 가장 작은 노드를 찾기에 적합한 자료구조니까..!










## 기타 - 추후 정리할 것


- **정렬(Heap Sort)**: 힙을 사용하여 데이터를 정렬할 수 있습니다.
- **그래프 알고리즘**: 다익스트라 알고리즘 등에서 최단 경로를 찾는 데 사용됩니다.

## 5. 시간 복잡도

- **삽입**: O(log n)
  - 전체적인 시간 n개의 데이터는 n * log n 이겠지
- **삭제**: O(log n)
- **최대/최소값 조회**: O(1)

## 6. 예제 코드 (Python)

```python
import heapq

# 최소 힙의 사용 예
min_heap = []
heapq.heappush(min_heap, 5)
heapq.heappush(min_heap, 2)
heapq.heappush(min_heap, 7)

print("최소값:", heapq.heappop(min_heap))  # 2
print("다음 최소값:", heapq.heappop(min_heap))  # 5

# 최대 힙의 사용 예
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -2)
heapq.heappush(max_heap, -7)

print("최대값:", -heapq.heappop(max_heap))  # 7
print("다음 최대값:", -heapq.heappop(max_heap))  # 5
```

힙 자료구조는 다양한 알고리즘과 문제 해결에 유용하며, 배열을 기반으로 효율적으로 구현할 수 있는 데이터 구조입니다.


# 우선순위 큐(Priority Queue)

우선순위 큐(Priority Queue)는 데이터 요소가 우선순위(priority)와 함께 저장되고, 요소가 큐에서 추출될 때 우선순위에 따라 처리되는 큐입니다. 기본적인 큐와는 달리, 우선순위 큐에서는 요소가 삽입될 때의 순서와는 상관없이 우선순위에 따라 요소를 추출합니다.

## 1. 기본 개념

### 1.1. 정의

- **우선순위 큐(Priority Queue)**: 큐의 각 요소가 우선순위를 가지며, 우선순위가 높은 요소가 먼저 제거되는 큐입니다. 우선순위는 숫자, 문자, 기타 기준으로 설정될 수 있습니다.

### 1.2. 동작 방식

- **삽입**: 새로운 요소를 큐에 추가하고, 그 요소의 우선순위에 따라 위치를 조정합니다.
- **삭제**: 우선순위가 가장 높은 요소(또는 가장 낮은 요소)가 큐에서 제거됩니다.
- **최상위 조회**: 현재 큐에서 가장 높은 우선순위를 가진 요소를 조회합니다.

## 2. 구현 방법

우선순위 큐는 다양한 방식으로 구현할 수 있으며, 각 방법에는 장단점이 있습니다.

### 2.1. 배열(Array)

- **삽입**: 배열의 끝에 추가하고, 우선순위에 따라 배열을 정렬합니다. (O(n) 시간 복잡도)
- **삭제**: 배열의 첫 번째 요소를 제거하고, 나머지를 왼쪽으로 이동합니다. (O(n) 시간 복잡도)
- **최상위 조회**: 배열의 첫 번째 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.2. 연결 리스트(Linked List)

- **삽입**: 우선순위에 맞게 위치를 찾고 삽입합니다. (O(n) 시간 복잡도)
- **삭제**: 우선순위가 가장 높은 요소를 찾고 제거합니다. (O(1) 시간 복잡도)
- **최상위 조회**: 리스트의 첫 번째 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.3. 힙(Heap)

- **삽입**: 힙의 특성에 맞게 요소를 삽입하고, 힙 속성을 유지합니다. (O(log n) 시간 복잡도)
- **삭제**: 힙의 루트 요소를 제거하고, 힙 속성을 유지합니다. (O(log n) 시간 복잡도)
- **최상위 조회**: 힙의 루트 요소를 조회합니다. (O(1) 시간 복잡도)

### 2.4. 이진 검색 트리(Binary Search Tree, BST)

- **삽입**: 우선순위에 따라 이진 검색 트리에 요소를 추가합니다. (O(log n) 평균 시간 복잡도)
- **삭제**: 우선순위가 가장 높은 요소를 찾아 삭제합니다. (O(log n) 평균 시간 복잡도)
- **최상위 조회**: 트리의 최대값을 조회합니다. (O(log n) 평균 시간 복잡도)

## 3. 힙을 사용한 우선순위 큐

힙을 사용한 우선순위 큐는 효율적인 삽입과 삭제 연산을 제공합니다. 이진 힙을 사용하면 다음과 같은 시간 복잡도를 가집니다:

- **삽입**: O(log n)
- **삭제**: O(log n)
- **최상위 조회**: O(1)

### 3.1. 힙의 동작

- **최대 힙(Max Heap)**: 가장 높은 우선순위를 가진 요소가 루트에 위치합니다. 삽입 시 새로운 요소를 트리의 마지막에 추가하고, 부모와 비교하여 힙 속성을 유지합니다. 삭제 시 루트 요소를 제거하고, 마지막 요소를 루트로 이동한 후, 하향식 힙화를 통해 힙 속성을 유지합니다.
- **최소 힙(Min Heap)**: 가장 낮은 우선순위를 가진 요소가 루트에 위치합니다. 삽입과 삭제 시의 동작은 최대 힙과 유사하지만, 비교 기준이 다릅니다.

## 4. 활용 사례

- **스케줄링**: 작업 스케줄링 및 작업 우선순위 결정.
- **그래프 알고리즘**: 다익스트라 알고리즘, 프림의 최소 신장 트리 알고리즘 등에서 최단 경로 계산.
- **알고리즘 설계**: 힙 정렬, A* 알고리즘 등.

## 5. 예제 코드 (Python)

```python
import heapq

# 우선순위 큐의 예제 (최소 힙 사용)
priority_queue = []
heapq.heappush(priority_queue, (3, 'Task A'))
heapq.heappush(priority_queue, (1, 'Task B'))
heapq.heappush(priority_queue, (2, 'Task C'))

print("최우선 작업:", heapq.heappop(priority_queue))  # (1, 'Task B')
print("다음 우선 작업:", heapq.heappop(priority_queue))  # (2, 'Task C')

# 우선순위 큐의 예제 (최대 힙 사용, 부호 변환 활용)
max_heap = []
heapq.heappush(max_heap, (-3, 'Task A'))
heapq.heappush(max_heap, (-1, 'Task B'))
heapq.heappush(max_heap, (-2, 'Task C'))

print("최대 우선 작업:", -heapq.heappop(max_heap)[0])  # 3
print("다음 최대 우선 작업:", -heapq.heappop(max_heap)[0])  # 2
```

우선순위 큐는 다양한 알고리즘과 응용에서 중요한 역할을 하며, 적절한 구현 방법을 선택하여 사용할 수 있습니다.


### 4.3 균형 이진 트리 (Balanced Binary Tree)
- **정의:** 모든 리프 노드의 높이 차이가 일정 범위 내에 있는 이진 트리입니다.
- **예시:** AVL 트리, 레드-블랙 트리 등이 있으며, 균형을 유지함으로써 탐색의 성능을 보장합니다.

### 4.4 트라이(Trie)
- **정의:** 문자열을 효율적으로 저장하고 탐색하기 위해 사용되는 트리 구조입니다.
- **특징:** 문자열의 공통 접두사를 공유하는 구조로, 검색 및 자동 완성 기능 등에 사용됩니다.

### 5. 트리의 활용
- **파일 시스템:** 디렉터리 구조는 트리로 표현됩니다.
- **데이터베이스 인덱스:** B-트리 및 B+트리는 데이터베이스에서 효율적인 검색을 위해 사용됩니다.
- **네트워크 라우팅:** 라우팅 테이블은 트리 구조를 사용해 최적 경로를 찾습니다.

